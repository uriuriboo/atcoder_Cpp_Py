{
  "atcodertemplate": {
    "prefix": "tmplt",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "using ll = long long;",
      "#define rep(i, n) for (ll i = 0; i < (n); i++)",
      "#define rep2(i,k,n) for(ll i = k;i < (n);i++)",
      "#define ALL(a) (a).begin(),(a).end()",
      "#define ALLR(a) (a).rbegin(),(a).rend()",
      "using P = pair<ll,ll>;",
      "const ll MOD = 1e9 + 7;",
      "const int INF = 1e9;",
      "const ll lINF = 1e18;",
      "const int dx[4] = {1, 0, -1, 0};",
      "const int dy[4] = {0, 1, 0, -1};",
      "template <class T> inline bool chmin(T &a, T b) {if (a > b) {a = b; return true;} return false;}",
      "template <class T> inline bool chmax(T &a, T b) {if (a < b) {a = b; return true;} return false;}\n",
      "template <class T>",
      "T GCD(T a, T b) {",
      "\tif (b == 0)",
      "\t\treturn a;",
      "\telse",
      "\t\treturn GCD(b, a % b);",
      "}\n",
      "template <class T>",
      "inline T LCM(T a, T b) {",
      "\t return b / GCD(a, b) * a;",
      "}\n",
      "template <class T>",
      "T nCr_naive(T n, int r) {",
      "\tT ret(1);",
      "\tfor (int i = 0; i < r; i++) {",
      "\t\tret *= n;",
      "\t\tret /= T(i + 1);",
      "\t\tn -= T(1);",
      "\t}",
      "\treturn ret;",
      "}\n",
      "int main(void){",
      "\tint n,$1;",
      "\tll ans = 0;",
      "\tcin >> n >> $1;",
      "\tvector<ll> a(n);",
      "\trep(i, n) cin >> a[i];\n",
      "\treturn 0;",
      "}"
    ],
    "description": "競プロのテンプレート"
  },
  "atcoder_n_templt": {
    "prefix": "ntemplt",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "using ll = long long;",
      "#define rep(i, n) for (ll i = 0; i < (n); i++)",
      "#define rep2(i,k,n) for(ll i = k;i < (n);i++)",
      "#define ALL(a) (a).begin(),(a).end()",
      "#define ALLR(a) (a).rbegin(),(a).rend()",
      "using P = pair<ll,ll>;",
      "const ll MOD = 1e9 + 7;",
      "const int INF = 1e9;",
      "const ll lINF = 1e18;",
      "const int dx[4] = {1, 0, -1, 0};",
      "const int dy[4] = {0, 1, 0, -1};",
      "template <class T> inline bool chmin(T &a, T b) {if (a > b) {a = b; return true;} return false;}",
      "template <class T> inline bool chmax(T &a, T b) {if (a < b) {a = b; return true;} return false;}\n",
      "int main(void){",
      "\tint n;",
      "\tll ans = 0;",
      "\tcin >> n;",
      "\tvector<ll> $1(n);",
      "\trep(i, n) cin >> $1[i];\n\n",
      "\treturn 0;",
      "}"
    ],
    "description": "nと要素数nの配列aを扱うテンプレート",
  },
  "n_m_template": {
    "prefix": "nmtmplt",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "using ll = long long;",
      "#define rep(i, n) for (ll i = 0; i < (n); i++)",
      "#define rep2(i,k,n) for(ll i = k;i < (n);i++)",
      "#define ALL(a) (a).begin(),(a).end()",
      "#define ALLR(a) (a).rbegin(),(a).rend()",
      "using P = pair<ll,ll>;",
      "const ll MOD = 1e9 + 7;",
      "const int INF = 1e9;",
      "const ll lINF = 1e18;",
      "const int dx[4] = {1, 0, -1, 0};",
      "const int dy[4] = {0, 1, 0, -1};",
      "template <class T> inline bool chmin(T &a, T b) {if (a > b) {a = b; return true;} return false;}",
      "template <class T> inline bool chmax(T &a, T b) {if (a < b) {a = b; return true;} return false;}\n",
      "int main(void){",
      "\tint n,$1;",
      "\tll ans = 0;",
      "\tcin >> n >> $1;",
      "\tvector<ll> $2(n);",
      "\trep(i, n) cin >> $2[i];\n\n",
      "\treturn 0;",
      "}"
    ],
    "description": "競プロのnとmの2値を扱うテンプレート"
  },
  "vector<int>略": {
    "prefix": "vi",
    "body": "vector<int> $1;\n",
    "description": "vector<int>の省略"
  },
  "vector<ll>略": {
    "prefix": "vl",
    "body": "vector<ll> $1;\n",
    "description": "vector<ll>の省略"
  },
  "vector<string>略":{
    "prefix": "vs",
    "body": "vector<string> $1;\n",
    "description": "vector<string>の省略"
  },
  "vector<vector<T>> ":{
    "prefix": "vv",
    "body": "vector<vector<$1>> $2($3,vector<$1>($4));\n",
    "description": "二次元配列",
  },
  "map<int,int>略":{
    "prefix": "mpii",
    "body": "map<int,int> $1;\n",
    "description": "map<int,int>略の省略"
  },
  "出力改行":{
    "prefix": "oen",
    "body": "cout << $1 << endl;\n",
    "description": "出力と改行を行う"
  },
  "ans 出力": {
    "prefix": "oans",
    "body": "cout << ans << endl;",
    "description": "ansの出力"
  },
  "Yes 出力": {
    "prefix": "oy",
    "body": "cout << \"Yes\" << endl;\n",
    "description": "Yesの出力"
  },
  "No 出力": {
    "prefix": "on",
    "body": "cout << \"No\" << endl;\n",
    "description": "Noの出力"
  },
  "組み合わせ": {
    "prefix": "comb",
    "body": [
      "template <class T>",
      "T nCr_naive(T n, int r) {",
      "\tT ret(1);",
      "\tfor (int i = 0; i < r; i++) {",
      "\t\tret *= n;",
      "\t\tret /= T(i + 1);",
      "\t\tn -= T(1);",
      "}",
      "\treturn ret;",
      "}",
    ],
    "description": "組み合わせの計算"
  },
  "基数変換": {
    "prefix": "convertb",
    "body": [
      "/*基数変換のためのライブラリ",
      "10進数xをy進数表記にして返す",
      "負の数は扱わない*/",
      "//string 型で返すためconvert_base.c_str()で変換する型の関数に渡す",
      "template <typename T>",
      "string convert_base(T x,T y){",
      "\tstring s;\n",
      "\twhile (x){",
      "\t\ts = to_string(x % y) + s;",
      "\t\tx /= y;",
      "\t}",
      "\treturn s;",
      "}",
      "//int型のみ扱いint型で返す",
      "int convert_base_int(int x,int y){",
      "\tstring s;\n",
      "\twhile (x){",
      "\t\ts = to_string(x % y) + s;",
      "\t\tx /= y;",
      "\t}",
      "\treturn atoi(s.c_str());",
      "}",
    ],
  },
  "素因数分解":{
    "prefix": "fprifa",
    "body": [
      "//(素因数,素因数の数)のペア",
      "vector<pair<ll,int>> prime_fac(ll n){",
      "\tvector<pair<ll,int>> res;",
      "\tfor(ll i = 2;i*i <= n;i++){",
      "\t\tint cnt = 0;",
      "\t\twhile(n%i == 0){",
      "\t\t\tcnt++;",
      "\t\t\tn /= i;",
      "\t\t}",
      "\tif(cnt != 0) res.emplace_back(make_pair(i,cnt));",
      "\t}",
      "\tif(n != 1) res.emplace_back(n,1);\n",
      "\treturn res;",
      "}",
    ],
    "description": "素因数分解を因数、その数のペアのvectorで返す",
  },
  "gcd,lcm(最大公約数、最小公倍数)":{
    "prefix": "gcdlcm",
    "body": [
      "template <class T>",
      "T GCD(T a, T b) {",
      "\tif (b == 0)",
      "\t\treturn a;",
      "\telse",
      "\t\treturn GCD(b, a % b);",
      "}\n",
      "template <class T>",
      "inline T LCM(T a, T b) {",
      "\t return b / GCD(a, b) * a;",
      "}\n",
    ],
    "description": "最大公約数と最大公約数:LCMはオーバーフローを避けるため計算の順序を変えた",
  },
  "editdistance": {
    "prefix": "editdist",
    "body": [
      "int editdistance(string s1,string s2){",
      "\tint a = s1.size(),b = s2.size(),cost;",
      "\tvector<vector<int>> dp(a+1,vector<int>(b+1,0));",
      "\trep(i,a+1) dp[i][0] = i;",
      "\trep(i,b+1) dp[0][i] = i;\n",
      "\trep(i,a){",
      "\t\trep(j,b){",
      "\t\t\tif(s1[i] == s2[j]) cost = 0;",
      "\t\t\telse cost = 1;",
      "\t\t\tdp[i+1][j+1] = min({dp[i+1][j]+1,dp[i][j+1]+1,dp[i][j]+cost});",
      "\t\t}",
      "\t}",
      "\treturn dp[a][b];",
      "}",
    ],
    "description": "エディットディスタンス"
  },
  "Grid0-1bsf": {
    "prefix": "fg01bsf",
    "body": [
      "/*0-1幅優先探索",
      "(スタート,ゴール,迷路)",
      "first が行 secondが列",
      "4方向のみ",
      "'.'または'g'がコストのない通路",
      "'#'がコストのある通路*/\n",
      "int bfs01(P s, P g, vector<string> &c){",
      "\tint H = c.size();",
      "\tint W = c[0].size();",
      "\tvector<vector<int>> d(H, vector<int>(W, -1)); //探索で通ったか、コストを記録",
      "\tdeque<P> que;",
      "\tque.push_front(s);",
      "\td[s.first][s.second] = 0;\n",
      "\twhile (que.size()){\n",
      "\t\tP p = que.front();",
      "\t\tque.pop_front();\n",
      "\t\trep(i, 4){",
      "\t\t\tint x = p.first + dx[i], y = p.second + dy[i];\n",
      "\t\t\tif (x < 0 || x >= H || y < 0 || y >= W)",
      "\t\t\t\tcontinue;",
      "\t\t\tif (d[x][y] != -1)",
      "\t\t\t\tcontinue;",
      "\t\t\tif (c[x][y] == '.' || c[x][y] == 'g'){",
      "\t\t\t\td[x][y] = d[p.first][p.second];",
      "\t\t\t\tque.push_front(make_pair(x,y));",
      "\t\t\t}",
      "\t\t\telse if(c[x][y] == '#'){",
      "\t\t\t\td[x][y] = d[p.first][p.second]+1;",
      "\t\t\t\tque.push_back(make_pair(x,y));",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn d[g.first][g.second];",
      "}",
    ],
    "description": "Gridグラフでの01bsf",
  },
  "Gridbsf": {
    "prefix": "fgbsf",
    "body": [
      "/*(スタート,ゴール,迷路)",
      "first が行 secondが列",
      "'#'の時通れない。それ以外の時に通れる。",
      "4方向のみ*/",
      "int bfs(P s, P g, vector<string> &c)",
      "{",
      "\tint H = c.size();",
      "\tint W = c[0].size();",
      "\tvector<vector<int>> d(H, vector<int>(W, -1)); //探索で通ったか、コストを記録",
      "\tqueue<P> que;",
      "\tque.push(s);",
      "\td[s.first][s.second] = 0;\n",
      "\twhile (que.size())",
      "\t{",
      "\t\tP p = que.front();",
      "\t\tque.pop();\n",
      "\t\trep(i, 4)",
      "\t\t{",
      "\t\t\tint x = p.first + dx[i], y = p.second + dy[i];\n",
      "\t\t\tif (x < 0 || x >= H || y < 0 || y >= W)",
      "\t\t\t\tcontinue;",
      "\t\t\tif (c[x][y] == '#')",
      "\t\t\t\tcontinue;",
      "\t\t\tif (d[x][y] != -1)",
      "\t\t\t\tcontinue;",
      "\t\t\tif (x == g.first && y == g.second)",
      "\t\t\t{",
      "\t\t\t\td[x][y] = d[p.first][p.second] + 1;",
      "\t\t\t\tbreak;",
      "\t\t\t}",
      "\t\t\tque.push(P(x, y));",
      "\t\t\td[x][y] = d[p.first][p.second] + 1;",
      "\t\t}",
      "\t}",
      "\treturn d[g.first][g.second];",
      "}",
    ],
    "description": "Gridグラフでの幅優先探索",
  },
  "dijkstra": {
    "prefix": "fdijk",
    "body": [
      "using TU = tuple<int,ll>;",
      "using Graph = vector<vector<TU>>;\n",
      "//s,Gは0オリジンに直しておくこと",
      "vector<ll> dijkstra(int s,Graph &G){",
      "\tint n = G.size();",
      "\tvector<ll> dist(n,lINF);",
      "\tdist[s] = 0;\n",
      "\tpriority_queue<pair<ll,int>,vector<pair<ll,int>>,greater<pair<ll,int>>> que;",
      "\tque.push(make_pair(dist[s],s));\n",
      "\twhile(!que.empty()){",
      "\t\tint v;",
      "\t\tll d;",
      "\t\ttie(d,v) = que.top();",
      "\t\tque.pop();\n",
      "\t\tif(d > dist[v]) continue;",
      "\t\tfor(auto nxt:G[v]){",
      "\t\t\tint nv;",
      "\t\t\tll w;",
      "\t\t\ttie(nv,w) = nxt;",
      "\t\t\tif(chmin(dist[nv],dist[v]+w))",
      "\t\t\t\tque.push(make_pair(dist[nv], nv));",
      "\t\t}",
      "\t}",
      "\treturn dist;",
      "}",
    ],
    "description": "ダイクストラ法の関数"
  },
  "isPrime": {
    "prefix": "fisP",
    "body": [
      "/*nが素数であるかbool型で判定*/",
      "bool isPrime(ll x){",
        "\tif(x < 2) return 0;",
        "\telse if(x == 2) return true;\n",
        "\tif(x%2 == 0) return false;",
        "\tfor(int i = 3;i*i <= x;i+=2){",
            "\t\tif(x%i == 0) return false;",
        "\t}",
        "\treturn true;",
    "}",
    ],
    "description": "素数判定",
  },
  "最長共通部分列": {
    "prefix": "lcsfunc",
    "body": [
      "int lcs(string A,string B){",
      "\tint a = A.size(),b = B.size();",
      "\tvector<vector<int>> dp(a+1,vector<int>(b+1,0));",
      "\trep(i,a){",
      "\t\trep(j,b){",
      "\t\t\tif(A[i] == B[j]){",
      "\t\t\t\tdp[i+1][j+1] =dp[i][j]+1;",
      "\t\t\t}",
      "\t\t\telse{",
      "\t\t\t\tdp[i+1][j+1] = max(dp[i+1][j],dp[i][j+1]);",
      "\t\t\t}",
      "\t\t}",
      "\t}",
      "\treturn dp[a][b];",
      "}",
    ],
    "description": "最長共通部分列",
  },
  "回文判定": {
    "prefix": "ispal",
    "body": [
      "bool ispal(string s){",
      "\tstring t = s;",
      "\treverse(t.begin(),t.end());",
      "\treturn s == t;",
      "}",
    ],
    "description": "回文判定をbool型で返す",
  },
  "累積和の計算(前から足す)": {
    "prefix": "cumsump",
    "body": [
      "//vector<int> a(n)に対して  c[0]は値がなし",
      "vector<int> c(n+1);",
      "rep2(i,1,n+1) c[i] = c[i-1]+a[i-1];",
    ],
    "description": "累積和の計算式",
  },
  "累積和の計算(後ろから)": {
    "prefix": "cumsumb",
    "body": [
      "vector<int> a(n);",
      "vector<int> cm(n,0);",
      "//cm[i] はi以降の累積和",
      "for(int i = n-2;i >= 0;i--){",
      "\tcm[i] = c[i+1] + a[i];",
      "}",
      "//cm[i]*a[i]でよく使う",
    ],
    "description": "累積和の計算式",
  },
  "bit探索":{
    "prefix": "pbit",
    "body": [
      "rep(bit,(1<<$1)){",
      "\tll cnt = 0;\n",
      "\trep(i,$1){",
      "\t\tif(bit & (1<<i)){",
      "\t\t\t$2",
      "\t\t}",
      "\t}\n",
      "\t$3",
      "}\n",
    ],
    "description": "bit探索"
  },
  "めぐり式二分探索":{
    "prefix": "binse",
    "body": [
      "bool P(int x) {\n",

      "}\n",
      
      "// P(x) = true となる最小の整数 x を返す",
      "int binary_search(int l,int r) {",
          "\t// P(left) = False, P(right) = True となるように",
          "\tint left, right; \n",
          
          "\twhile (right - left > 1) {",
              "\t\tint mid = left + (right - left) / 2;",
              "\t\tif (P(mid)) right = mid;",
              "\t\telse left = mid;",
          "\t}",
          "\treturn right;",
      "}\n",
    ],
    "description": "めぐり式二分探索"
  }
}
